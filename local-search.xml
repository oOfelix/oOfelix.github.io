<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mysql高级</title>
    <link href="/2022/03/13/mysql2/"/>
    <url>/2022/03/13/mysql2/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mysql逻辑架构"><a href="#一、Mysql逻辑架构" class="headerlink" title="一、Mysql逻辑架构"></a>一、Mysql逻辑架构</h1><h2 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png"><img src="/mysql2.assets/20200813170808.png" alt="img"></a></p><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作</p><table><thead><tr><th>Management Serveices &amp; Utilities</th><th>系统管理和控制工具</th></tr></thead><tbody><tr><td>SQL Interface</td><td>SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</td></tr><tr><td>Parser</td><td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td></tr><tr><td>Optimizer</td><td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。</td></tr><tr><td>Cache 和 Buffer</td><td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等</td></tr></tbody></table><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同</p><table><thead><tr><th>对比项</th><th>MylSAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁（不适合高并发）</td><td>行锁（适合高并发操作）</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引，还缓存真实数据。对内存要求较高</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</p><h1 id="二、性能与JOIN"><a href="#二、性能与JOIN" class="headerlink" title="二、性能与JOIN"></a>二、性能与JOIN</h1><h2 id="1、性能下降原因"><a href="#1、性能下降原因" class="headerlink" title="1、性能下降原因"></a>1、性能下降原因</h2><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p><strong>单值索引</strong></p><p>创建语句</p><figure class="highlight oxygene"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_表名_字段名 <span class="hljs-keyword">ON</span> 表名(字段名)<span class="hljs-punctuation">;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>复合索引</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CREATE</span> INDEX idx_表名_字段名<span class="hljs-number">1</span>字段名<span class="hljs-number">2</span>... <span class="hljs-literal">ON</span> 表名(字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span> ...);Copy<br></code></pre></td></tr></table></figure><h3 id="关联太多JOIN"><a href="#关联太多JOIN" class="headerlink" title="关联太多JOIN"></a>关联太多JOIN</h3><p>内连接、外连接的表不要过多</p><h3 id="服务器调优及参数设置"><a href="#服务器调优及参数设置" class="headerlink" title="服务器调优及参数设置"></a>服务器调优及参数设置</h3><h2 id="2、SQL执行加载顺序"><a href="#2、SQL执行加载顺序" class="headerlink" title="2、SQL执行加载顺序"></a>2、SQL执行加载顺序</h2><h3 id="手写顺序"><a href="#手写顺序" class="headerlink" title="手写顺序"></a>手写顺序</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112248.png"><img src="/mysql2.assets/20200814112248.png" alt="img"></a></p><p>随着 Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而<strong>动态调整执行顺序</strong></p><p>下面是经常出现的查询顺序：</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112330.png"><img src="/mysql2.assets/20200814112330.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112343.png"><img src="/mysql2.assets/20200814112343.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814191644.png"><img src="/mysql2.assets/20200814191644.png" alt="img"></a></p><h2 id="3、7种JOIN"><a href="#3、7种JOIN" class="headerlink" title="3、7种JOIN"></a>3、7种JOIN</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814150926.png"><img src="/mysql2.assets/20200814150926.png" alt="img"></a></p><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a><strong>建表语句</strong></h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_dept` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=<span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_emp` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `<span class="hljs-type">name</span>` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `age` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `deptId` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, empno <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY KEY</span> (`id`), KEY `idx_dept_id` (`deptId`)<br><span class="hljs-meta">#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)</span><br>) ENGINE=INNODB AUTO_INCREMENT=<span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;华山&#x27;</span>,<span class="hljs-string">&#x27;华山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;丐帮&#x27;</span>,<span class="hljs-string">&#x27;洛阳&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;峨眉&#x27;</span>,<span class="hljs-string">&#x27;峨眉山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;武当&#x27;</span>,<span class="hljs-string">&#x27;武当山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;明教&#x27;</span>,<span class="hljs-string">&#x27;光明顶&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;少林&#x27;</span>,<span class="hljs-string">&#x27;少林寺&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;风清扬&#x27;</span>,<span class="hljs-number">90</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100001</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;岳不群&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100002</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;令狐冲&#x27;</span>,<span class="hljs-number">24</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100003</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;洪七公&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100004</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;乔峰&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100005</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;灭绝师太&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100006</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;周芷若&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100007</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张三丰&#x27;</span>,<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">100008</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张无忌&#x27;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>,<span class="hljs-number">100009</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-type">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;韦小宝&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">100010</span>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><ul><li>笛卡尔积</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp<span class="hljs-punctuation">;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>t_dept共20条记录，t_emp共6条记录。两表共同查询后共120条记录</p><ul><li>内连接</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153140.png"><img src="/mysql2.assets/20200814153140.png" alt="img"></a></p><ul><li>左外连接</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153254.png"><img src="/mysql2.assets/20200814153254.png" alt="img"></a></p><ul><li>右外连接</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153413.png"><img src="/mysql2.assets/20200814153413.png" alt="img"></a></p><ul><li>左外连接<strong>取左表的独有部分</strong></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153909.png"><img src="/mysql2.assets/20200814153909.png" alt="img"></a></p><ul><li>右外连接<strong>取右表的独有部分</strong></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153844.png"><img src="/mysql2.assets/20200814153844.png" alt="img"></a></p><p><strong>注意</strong>：判断字段是否为NULL时，<strong>不能使用’&#x3D;’</strong></p><p>因为</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">= NULLCopy</span><br></code></pre></td></tr></table></figure><p>的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">IS</span> NULLCopy<br></code></pre></td></tr></table></figure><p>来进行判空</p><ul><li>全外连接</li></ul><p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814154554.png"><img src="/mysql2.assets/20200814154554.png" alt="img"></a></p><ul><li>查询两表独有内容</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814155138.png"><img src="/mysql2.assets/20200814155138.png" alt="img"></a></p><h1 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h1><h2 id="1、什么是索引"><a href="#1、什么是索引" class="headerlink" title="1、什么是索引"></a>1、什么是索引</h2><ul><li><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。可以得到索引的本质： <strong>索引是数据结构</strong>。</p><p>可以简单理解为：<strong>排好序的快速查找数据结构</strong></p></li><li><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814173647.png"><img src="/mysql2.assets/20200814173647.png" alt="img"></a></p><ul><li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录</li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li></ul><h2 id="2、索引的优缺点"><a href="#2、索引的优缺点" class="headerlink" title="2、索引的优缺点"></a>2、索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>提高数据检索的效率</strong>，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>虽然索引大大提高了查询速度，同时却<strong>会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li></ul><h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>创建</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span>(<span class="hljs-keyword">column</span>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>单值索引</p><ul><li><p>定义：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--和表一起创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br><span class="hljs-keyword">PRIMARY KEY</span>(id), <br>KEY (customer_name) <span class="hljs-comment">--单值索引</span><br>);<br><br><span class="hljs-comment">--单独创建单值索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_customer_name <span class="hljs-keyword">ON</span> customer(customer_name);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>唯一索引</p><ul><li><p>定义：索引列的值必须唯一，但允许有空值</p></li><li><p>语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--和表一起创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br><span class="hljs-keyword">PRIMARY KEY</span>(id), <br>KEY (customer_name), <span class="hljs-comment">--单值索引</span><br><span class="hljs-keyword">UNIQUE</span> (customer_no) <span class="hljs-comment">--唯一索引</span><br>);<br><br><span class="hljs-comment">--单独创建唯一索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> idx_customer_no <span class="hljs-keyword">ON</span> customer(customer_no);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>主键索引</p><ul><li><p>定义：设定为主键后数据库会<strong>自动建立索引</strong>，innodb为聚簇索引</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br><span class="hljs-keyword">PRIMARY</span> KEY(id) <span class="hljs-comment">--主键索引</span><br>);<br><br><span class="hljs-comment">--单独创建主键索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY customer(customer_no);<br><br><span class="hljs-comment">--删除主键索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br><br><span class="hljs-comment">--修改建主键索引</span><br>必须先删除掉(<span class="hljs-keyword">drop</span>)原索引，再新建(<span class="hljs-keyword">add</span>)索引<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>复合索引</p><ul><li><p>定义：即一个索引包含多个列</p></li><li><p>语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--和表一起创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br><span class="hljs-keyword">PRIMARY KEY</span>(id), <br>KEY (customer_name), <span class="hljs-comment">--单值索引</span><br><span class="hljs-keyword">UNIQUE</span> (customer_no), <span class="hljs-comment">--唯一索引</span><br>KEY (customer_no,customer_name) <span class="hljs-comment">--复合索引</span><br>);<br><br><span class="hljs-comment">--单独创建复合索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_no_name <span class="hljs-keyword">ON</span> customer(customer_no,customer_name);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4、MySQL的索引"><a href="#4、MySQL的索引" class="headerlink" title="4、MySQL的索引"></a>4、MySQL的索引</h2><h3 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h3><p>树的内容参照<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#B%E6%A0%91%E3%80%81B-%E5%92%8CB-%E6%A0%91">JAVA数据结构 B树、B+树和B*树</a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153029.png"><img src="/mysql2.assets/20200815153029.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153043.png"><img src="/mysql2.assets/20200815153043.png" alt="img"></a></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>B树的<strong>关键字和记录是放在一起的</strong>，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，<strong>记录只放在叶子节点中</strong></li><li>在 B树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录 的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B树多，树高比 B树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故</li></ul><p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><ul><li>B+树的磁盘读写代价更低<ul><li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了</li></ul></li><li>B+树的查询效率更加稳定<ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li></ul></li></ul><h3 id="MySQL中的B-树"><a href="#MySQL中的B-树" class="headerlink" title="MySQL中的B+树"></a>MySQL中的B+树</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822173605.png"><img src="/mysql2.assets/20200822173605.png" alt="img"></a></p><p>MySQL在创建表时，会根据主键来创建主键索引（如果没有主键，会用一个隐藏值来作为主键）。主键索引所构建的B+树，表中所有的记录都存放在了树的最后一层。<strong>且与一般的B+树不同的是：叶子节点间的指针是双向的</strong></p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822185520.png"><img src="/mysql2.assets/20200822185520.png" alt="img"></a></p><p>创建复合索引时，会将作为<strong>复合索引字段的值</strong>进行排序并放在B+树的最后一层中，同时还会将其<strong>对应的主键值</strong>放在其后。如：</p><table><thead><tr><th>a（主键）</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>1</td><td>1</td><td>a</td></tr></tbody></table><p>其中字段a为主键，字段bcd共同作为复合索引，此时存放在最后一层的数据就是：111（复合索引） 2（主键索引）</p><p>根据这个特点，可以看出复合索引具有以下使用方法</p><ul><li><p>最佳左前缀：使用复合索引的顺序必须和创建的<strong>顺序一致</strong></p></li><li><p>覆盖索引的同时，可以带上主键字段，如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">SELECT <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c, d <span class="hljs-selector-tag">FROM</span> t_emp;Copy<br></code></pre></td></tr></table></figure><p>因为<strong>主键字段和复合索引一起存放在了复合索引说产生的B+树的最后一层</strong>。如果需要a字段，无需进行全表扫描</p></li><li><p>如果进行范围查找，可能会进行全表扫描，这取决于处在范围内记录的多少</p><ul><li><p><strong>记录多</strong>，从复合索引映射到主键索引的次数过多，成本过高，<strong>会直接进行全表扫描</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175336.png"><img src="/mysql2.assets/20200822175336.png" alt="img"></a></p></li><li><p><strong>记录少</strong>，先<strong>使用复合索引</strong>，然后映射到全表中的对应记录上</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">80</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175403.png"><img src="/mysql2.assets/20200822175403.png" alt="img"></a></p></li><li><p>但是使用<strong>覆盖索引</strong>，无论记录多少，都会用到索引</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175611.png"><img src="/mysql2.assets/20200822175611.png" alt="img"></a></p></li></ul></li><li><p>不带WHERE也可以通过复合索引查找到主键+复合索引的记录</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> id, age, <span class="hljs-type">name</span>, deptId <span class="hljs-keyword">FROM</span> t_emp ;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175746.png"><img src="/mysql2.assets/20200822175746.png" alt="img"></a></p></li></ul><h2 id="5、索引的使用场景"><a href="#5、索引的使用场景" class="headerlink" title="5、索引的使用场景"></a>5、索引的使用场景</h2><h3 id="适合索引的场景"><a href="#适合索引的场景" class="headerlink" title="适合索引的场景"></a>适合索引的场景</h3><ul><li>主键自动建立唯一索引</li><li>频繁作为<strong>查询条件</strong>的字段应该创建索引</li><li>查询中与其它表关联的字段，<strong>外键关系</strong>建立索引</li><li>单键&#x2F;组合索引的选择问题，<strong>组合索引性价比更高</strong></li><li>查询中<strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中<strong>统计</strong>或者<strong>分组</strong>字段</li></ul><h3 id="不适合索引的场景"><a href="#不适合索引的场景" class="headerlink" title="不适合索引的场景"></a>不适合索引的场景</h3><ul><li>表<strong>记录太少</strong>（有无索引差别不大）</li><li>经常<strong>增删改</strong>的表或者字段</li><li>Where 条件里用不到的字段不创建索引</li><li><strong>过滤性不好</strong>的不适合建索引（重复性较高，比如国籍、性别之类的字段）</li></ul><h1 id="四、Explain-性能分析"><a href="#四、Explain-性能分析" class="headerlink" title="四、Explain 性能分析"></a>四、Explain 性能分析</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>使用 <strong>EXPLAIN</strong> 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。<strong>分析</strong>你的查询语句或是表结构的<strong>性能瓶颈</strong></p><h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--EXPLAIN + SQL语句，如：</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>Explain 执行后返回的信息：</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815171636.png"><img src="/mysql2.assets/20200815171636.png" alt="img"></a></p><h2 id="3、表头字段介绍"><a href="#3、表头字段介绍" class="headerlink" title="3、表头字段介绍"></a>3、表头字段介绍</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY KEY</span> (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY KEY</span> (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t3(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY KEY</span> (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t4(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY KEY</span> (id));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t1_&#x27;</span>,FLOOR(<span class="hljs-number">1</span>+RAND()*<span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t2(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t2_&#x27;</span>,FLOOR(<span class="hljs-number">1</span>+RAND()*<span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t3(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t3_&#x27;</span>,FLOOR(<span class="hljs-number">1</span>+RAND()*<span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t4(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t4_&#x27;</span>,FLOOR(<span class="hljs-number">1</span>+RAND()*<span class="hljs-number">1000</span>)));<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h3><p>id是select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><ul><li><p><strong>id相同</strong>：执行顺序为 <strong>从上至下执行</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">EXPLAIN SELECT * FROM <span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t2</span>, <span class="hljs-built_in">t3</span> WHERE <span class="hljs-built_in">t1</span>.id = <span class="hljs-built_in">t2</span>.id <span class="hljs-keyword">AND </span><span class="hljs-built_in">t2</span>.id = <span class="hljs-built_in">t3</span>.id<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815173157.png"><img src="/mysql2.assets/20200815173157.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t1, t2, t3</strong></p></li><li><p><strong>id不同</strong>：执行顺序为 <strong>id大的先执行</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> t2.id <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">WHERE</span> t2.id = <br>(<span class="hljs-keyword">SELECT</span> t1.id <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> t1.id = <br>(<span class="hljs-keyword">SELECT</span> t3.id <span class="hljs-keyword">FROM</span> t3)<br>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174216.png"><img src="/mysql2.assets/20200815174216.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t3, t1, t2</strong></p></li><li><p><strong>id相同又不同</strong>： 执行顺序为</p><ul><li>id不同时，值较大的先执行</li><li>id相同时，从上至下执行</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">EXPLAIN SELECT * FROM (SELECT <span class="hljs-built_in">t3</span>.id FROM <span class="hljs-built_in">t3</span>) <span class="hljs-built_in">s1</span>, <span class="hljs-built_in">t2</span> WHERE <span class="hljs-built_in">s1</span>.id = <span class="hljs-built_in">t2</span>.id<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174740.png"><img src="/mysql2.assets/20200815174740.png" alt="img"></a></p><p>查询时，表的<strong>加载顺序为t3, t2, 虚表dervied2</strong></p><ul><li>其中dervied<strong>2</strong> 的 2，为 id &#x3D; 2</li></ul></li></ul><h3 id="select-type：查询操作类型"><a href="#select-type：查询操作类型" class="headerlink" title="select_type：查询操作类型"></a>select_type：查询操作类型</h3><p>select_type代表<strong>查询的类型</strong>，主要是用于区别<strong>普通查询、联合查询、子查询等</strong>的复杂查询</p><table><thead><tr><th>select_type 属性</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的 select 查询,查询中<strong>不包含子查询或者 UNION</strong></td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子部分，<strong>最外层</strong>查询则被标记为 Primary</td></tr><tr><td>DERIVED</td><td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了<strong>子查询</strong></td></tr><tr><td>DEPEDENT SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询,<strong>子查询基于外层</strong></td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td><strong>无法使用缓存</strong>的子查询</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表<strong>获取结果</strong>的SELECT</td></tr></tbody></table><ul><li><p>SUBQUERY 和 DEPEDENT SUBQUERY</p><ul><li>都是 WHERE 后面的条件，SUBQUERY 是单个值（&#x3D;），DEPEDENT SUBQUERY 是一组值（IN）</li></ul></li><li><p>UNCACHEABLE SUBQUERY</p><ul><li>当使用了**@@来引用系统变量**的时候，不会使用缓存</li></ul></li><li><p>UNION 和 UNION RESULT</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816135453.png"><img src="/mysql2.assets/20200816135453.png" alt="img"></a></p></li></ul><h3 id="table：表的来源"><a href="#table：表的来源" class="headerlink" title="table：表的来源"></a>table：表的来源</h3><p>table表示这个数据是基于哪张表的</p><h3 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a>type：访问类型</h3><p>type 是查询的访问类型。<strong>是较为重要的一个指标</strong>，结果值从最好到最坏依次是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">all</span><br><br><span class="hljs-comment">--常见的顺序为</span><br><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; range &gt; <span class="hljs-keyword">index</span> &gt; allCopy<br></code></pre></td></tr></table></figure><p>一般来说，得保证查询<strong>至少达到 range 级别</strong>，最好能达到 ref</p><table><thead><tr><th>类型名</th><th>含义</th></tr></thead><tbody><tr><td>SYSTEM</td><td>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也<strong>可以忽略不计</strong></td></tr><tr><td>CONST</td><td>表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</td></tr><tr><td>EQ_REF</td><td>唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>。常见于主键或唯一索引扫描</td></tr><tr><td>REF</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行， 然而，它<strong>可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体</td></tr><tr><td>RANGE</td><td>只检索给定<strong>范围</strong>的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引</td></tr><tr><td>INDEX</td><td>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</td></tr><tr><td>ALL</td><td>Full Table Scan，将遍历全表以找到匹配的行</td></tr></tbody></table><ul><li><p>REF</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--其中deptId为索引，且用到了&#x27; = &#x27;</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">3</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165420.png"><img src="/mysql2.assets/20200816165420.png" alt="img"></a></p></li><li><p>RANGE</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--其中deptId为索引，用到了 BETWEEN...AND... , IN , &gt; , &lt; 等范围查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId &gt; <span class="hljs-number">3</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816213631.png"><img src="/mysql2.assets/20200816213631.png" alt="img"></a></p></li><li><p>INDEX</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--其中deptId为索引，查找了整张表时，用到了索引</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> deptId <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165651.png"><img src="/mysql2.assets/20200816165651.png" alt="img"></a></p></li><li><p>ALL</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--其中name为非索引</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165722.png"><img src="/mysql2.assets/20200816165722.png" alt="img"></a></p></li></ul><h3 id="possible-key：可能用到的索引"><a href="#possible-key：可能用到的索引" class="headerlink" title="possible_key：可能用到的索引"></a>possible_key：可能用到的索引</h3><p>显示<strong>可能</strong>应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一 定被查询实际使用</strong></p><h3 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a>key：实际使用的索引</h3><p><strong>实际使用的索引</strong>。如果为NULL，则没有使用索引</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816172950.png"><img src="/mysql2.assets/20200816172950.png" alt="img"></a></p><p>MySQL推测可能用到主键索引和idx_dept_id索引，实际上用到的是主键索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h4><p>当查找的字段与建立的索引的匹配（查询的字段都是索引，但不需要全是索引）时，会发生覆盖索引。MySQL推测使用的索引为NULL，而实际上会使用索引</p><p>有以下两种解释</p><ul><li>select的数据列<strong>只用从索引中就能够取得</strong>，不必从数据表中读取，换句话说<strong>查询列要被所使用的索引覆盖</strong></li><li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</li></ul><p>注意：要使用覆盖索引，则<strong>只取出需要的列</strong>（被令为索引），<strong>不要</strong>使用 SELECT *</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--其中id和deptId都为索引</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> id, deptId <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173253.png"><img src="/mysql2.assets/20200816173253.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173228.png"><img src="/mysql2.assets/20200816173228.png" alt="img"></a></p><h3 id="key-len：索引使用字节数"><a href="#key-len：索引使用字节数" class="headerlink" title="key_len：索引使用字节数"></a>key_len：索引使用字节数</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引</p><p><strong>ken_len 越长，说明索引使用的越充分</strong></p><h3 id="ref：显示被使用的索引的具体信息"><a href="#ref：显示被使用的索引的具体信息" class="headerlink" title="ref：显示被使用的索引的具体信息"></a>ref：显示被使用的索引的具体信息</h3><p>ref显示索引的哪一列被使用了，如果可能的话，可以是一个常数。哪些列或常量被用于查找索引列上的值</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId = t_dept.id;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816194305.png"><img src="/mysql2.assets/20200816194305.png" alt="img"></a></p><h3 id="rows：被查询的行数"><a href="#rows：被查询的行数" class="headerlink" title="rows：被查询的行数"></a>rows：被查询的行数</h3><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。<strong>越少越好！</strong></p><p><strong>验证</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--先删除索引</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_dept_id <span class="hljs-keyword">ON</span> t_emp;<br><br><span class="hljs-comment">--查找</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId = t_dept.id;<br><br><span class="hljs-comment">--再创建索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_dept_id <span class="hljs-keyword">ON</span> t_emp(deptId);<br><br><span class="hljs-comment">--查找</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId = t_dept.id;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>结果如下</strong></p><ul><li><p>未使用索引时，一共需要查询26行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195241.png"><img src="/mysql2.assets/20200816195241.png" alt="img"></a></p></li><li><p>使用索引后，一共需要查询6行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195401.png"><img src="/mysql2.assets/20200816195401.png" alt="img"></a></p></li></ul><h3 id="Extra：额外重要信息"><a href="#Extra：额外重要信息" class="headerlink" title="Extra：额外重要信息"></a>Extra：额外重要信息</h3><p>其他的额外<strong>重要</strong>的信息</p><ul><li><p><strong>Using filesort</strong>：使用外部索引排序（未使用用户创建的索引）</p><ul><li>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”</li><li>出现 Using filesort <strong>说明SQL语句设计的不好</strong>，<strong>没有按照创建的索引进行排序</strong>，或者<strong>未按照索引指定的顺序进行排序</strong></li></ul><p><strong>演示</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--创建符合索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_empno_age <span class="hljs-keyword">ON</span> t_emp(empno, age);<br><br><span class="hljs-comment">--进行查询操作，通过 age 字段进行排序（未按照复合索引顺序进行排序查询）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br><br><span class="hljs-comment">--进行查询操作，通过 empno 或者 empno + age 字段进行排序（按照复合索引顺序进行排序查询）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno, age;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205145.png"><img src="/mysql2.assets/20200816205145.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205226.png"><img src="/mysql2.assets/20200816205226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205112.png"><img src="/mysql2.assets/20200816205112.png" alt="img"></a></p></li><li><p><strong>Using temporary</strong></p><ul><li>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。<strong>常见于排序 order by 和分组查询 group by</strong></li><li>出现 Using temporary <strong>说明SQL语句设计的非常不好</strong>，可能是因为没有按照顺序使用复合索引</li></ul><p><strong>演示</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--进行查询操作， 通过 age 字段进行分组（未按照复合索引顺序进行排序查询）</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_empno_age <span class="hljs-keyword">ON</span> t_emp(empno, age);<br><br><span class="hljs-comment">----进行查询操作，通过 empno 或者 empno + age 字段进行分组（按照复合索引顺序进行排序查询）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno, age;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210843.png"><img src="/mysql2.assets/20200816210843.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210908.png"><img src="/mysql2.assets/20200816210908.png" alt="img"></a></p></li></ul><p><strong>重要结论</strong></p><p>如果创建了<strong>复合索引</strong>，一定要<strong>按照复合索引的顺序来使用</strong>，否则会使得性能大幅下降</p><ul><li><p><strong>Using index</strong></p><ul><li>Using index 代表表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)，详见<a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">key：实际用到的索引——覆盖索引</a>，避免访问了表的数据行，<strong>效率不错</strong>！</li><li>如果同时出现 using where，表明<strong>索引被用来执行索引键值的查找</strong></li><li>如果没有同时出现 using where，表明<strong>索引只是用来读取数据</strong>而非利用索引执行查找。</li></ul><p><strong>演示</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--查询 age 字段，使用了WHERE</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt;<span class="hljs-number">100000</span>;<br><br><span class="hljs-comment">--查询 empno 和 age 字段，未使用WHERE</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno, age <span class="hljs-keyword">FROM</span> t_emp;<br><br><span class="hljs-comment">--查询 empno 和 name 字段 （name字段不是索引）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno, <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212055.png"><img src="/mysql2.assets/20200816212055.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212129.png"><img src="/mysql2.assets/20200816212129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212243.png"><img src="/mysql2.assets/20200816212243.png" alt="img"></a></p></li><li><p>Using where</p><ul><li>表明使用了 where 过滤</li></ul></li><li><p>Using join buffer</p><ul><li>使用了连接缓存</li></ul></li><li><p>impossible where</p><ul><li>where 子句的值总是 false，不能用来获取任何元组</li></ul></li><li><p>select tables optimized away</p><ul><li>在没有 GROUP BY 子句的情况下，基于索引优化 MIN&#x2F;MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li></ul></li></ul><h1 id="五、单表查询优化"><a href="#五、单表查询优化" class="headerlink" title="五、单表查询优化"></a>五、单表查询优化</h1><h2 id="1、全值匹配很快捷"><a href="#1、全值匹配很快捷" class="headerlink" title="1、全值匹配很快捷"></a>1、全值匹配很快捷</h2><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--建立符合索引（age, deptId, name）</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_ade <span class="hljs-keyword">ON</span> t_emp(age, deptId, <span class="hljs-type">NAME</span>);<br><br><span class="hljs-comment">--查找</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span> <span class="hljs-keyword">AND</span> age = <span class="hljs-number">90</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164200.png"><img src="/mysql2.assets/20200817164200.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="/mysql2.assets/20200817164226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164241.png"><img src="/mysql2.assets/20200817164241.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="/mysql2.assets/20200817164506.png" alt="img"></a></p><p>可以看到，<strong>复合索引都被用到了，并且SQL中查询字段的顺序，跟使用索引中字段的顺序，没有关系</strong>。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p><p><strong>结论：全职匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到</strong></p><h2 id="2、最佳左前缀法则"><a href="#2、最佳左前缀法则" class="headerlink" title="2、最佳左前缀法则"></a>2、最佳左前缀法则</h2><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--先删除之前创建的单值索引</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_dept_id <span class="hljs-keyword">ON</span> t_emp; <br><br><span class="hljs-comment">--查询，未按照最佳左前缀法则</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span>  age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--查询，完全按照最佳左前缀法则</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164932.png"><img src="/mysql2.assets/20200817164932.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164948.png"><img src="/mysql2.assets/20200817164948.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817165100.png"><img src="/mysql2.assets/20200817165100.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="/mysql2.assets/20200817164226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="/mysql2.assets/20200817164506.png" alt="img"></a></p><p>可以看到，查询<strong>字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效</strong></p><p><strong>原因</strong>：使用复合索引，需要<strong>遵循最佳左前缀法则</strong>，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong></p><p><strong>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong></p><h2 id="3、索引列上不计算"><a href="#3、索引列上不计算" class="headerlink" title="3、索引列上不计算"></a>3、索引列上不计算</h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），<strong>可能会导致索引失效而转向全表扫描</strong></p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--直接查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">NAME</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--使用MySQL函数查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> LEFT(age,<span class="hljs-number">2</span>) = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170139.png"><img src="/mysql2.assets/20200817170139.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170522.png"><img src="/mysql2.assets/20200817170522.png" alt="img"></a></p><p>可以看出，当age字段使用了left函数以后，<strong>导致索引完全失效</strong></p><p><strong>结论：等号左边无计算</strong></p><h2 id="4、范围之后全失效"><a href="#4、范围之后全失效" class="headerlink" title="4、范围之后全失效"></a>4、范围之后全失效</h2><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--范围查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">NAME</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--未使用范围查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171833.png"><img src="/mysql2.assets/20200817171833.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817172159.png"><img src="/mysql2.assets/20200817172159.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171903.png"><img src="/mysql2.assets/20200817171903.png" alt="img"></a></p><p>可以看出，当对age字段使用范围查询后，使得范围后面的索引失效了</p><p><strong>建议：</strong>将可能做范围查询的字段的索引顺序<strong>放在最后</strong></p><p><strong>结论：使用范围查询后，如果范围内的记录过多，会导致索引失效</strong>，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快</p><h2 id="5、覆盖索引多使用"><a href="#5、覆盖索引多使用" class="headerlink" title="5、覆盖索引多使用"></a>5、覆盖索引多使用</h2><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--查询所有字段</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">--查询索引字段</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173338.png"><img src="/mysql2.assets/20200817173338.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173314.png"><img src="/mysql2.assets/20200817173314.png" alt="img"></a></p><p><strong>结论：使用覆盖索引（Using index）会提高检索效率</strong></p><h2 id="6、使用不等会失效"><a href="#6、使用不等会失效" class="headerlink" title="6、使用不等会失效"></a>6、使用不等会失效</h2><p>在使用<strong>不等于(!&#x3D; 或者&lt;&gt;)时</strong>，有时会无法使用索引会导致全表扫描</p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--SQL语句中有不等于</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age != <span class="hljs-number">90</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &lt;&gt; <span class="hljs-number">90</span>;<br><br><span class="hljs-comment">--SQL语句中没有不等于</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180448.png"><img src="/mysql2.assets/20200817180448.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180505.png"><img src="/mysql2.assets/20200817180505.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180521.png"><img src="/mysql2.assets/20200817180521.png" alt="img"></a></p><p><strong>结论：尽量不要使用不等于</strong></p><h2 id="7、使用NULL值要小心"><a href="#7、使用NULL值要小心" class="headerlink" title="7、使用NULL值要小心"></a>7、使用NULL值要小心</h2><p>在使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br>或者<br><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>时，可能会导致索引失效</p><p>但是如果<strong>允许字段为空</strong>，则</p><ul><li>IS NULL 不会导致索引失效</li><li>IS NOT NULL 会导致索引失效</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181044.png"><img src="/mysql2.assets/20200817181044.png" alt="img"></a></p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181116.png"><img src="/mysql2.assets/20200817181116.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181137.png"><img src="/mysql2.assets/20200817181137.png" alt="img"></a></p><h2 id="8、模糊查询加右边"><a href="#8、模糊查询加右边" class="headerlink" title="8、模糊查询加右边"></a>8、模糊查询加右边</h2><p>要使用模糊查询时，<strong>百分号最好加在右边，而且进行模糊查询的字段必须是单值索引</strong></p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--创建单值索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_name <span class="hljs-keyword">ON</span> t_emp(<span class="hljs-type">NAME</span>);<br><br><span class="hljs-comment">--进行模糊查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风&#x27;</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;风%&#x27;</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风%&#x27;</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="/mysql2.assets/20200817183416.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183401.png"><img src="/mysql2.assets/20200817183401.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="/mysql2.assets/20200817183416.png" alt="img"></a></p><p>可以看出，对索引使用模糊查询时，<strong>只有当百分号在右边，索引为单值索引且模糊查询语句在最右边时，索引才会生效</strong></p><p>其他情况均失效了</p><p><strong>但是</strong>有时必须使用其他类型的模糊查询，这时就需要用<strong>覆盖索引</strong>来解决索引失效的问题</p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风&#x27;</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;风%&#x27;</span>;<br><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-type">NAME</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风%&#x27;</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="/mysql2.assets/20200817183741.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183801.png"><img src="/mysql2.assets/20200817183801.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="/mysql2.assets/20200817183741.png" alt="img"></a></p><p><strong>结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率</strong></p><h2 id="9、字符串加单引号"><a href="#9、字符串加单引号" class="headerlink" title="9、字符串加单引号"></a>9、字符串加单引号</h2><p>当字段为字符串时，查询时必须带上单引号。否则<strong>会发生自动的类型转换</strong>，从而发生全表扫描</p><p><strong>用于查询的表</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817203952.png"><img src="/mysql2.assets/20200817203952.png" alt="img"></a></p><p><strong>其中card_id字段为varchar类型，且设置了单值索引</strong></p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--使用了单引号</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id = <span class="hljs-string">&#x27;1&#x27;</span>;<br><br><span class="hljs-comment">--未使用单引号，发生自动类型转换</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id = <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204047.png"><img src="/mysql2.assets/20200817204047.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204027.png"><img src="/mysql2.assets/20200817204027.png" alt="img"></a></p><h2 id="10、尽量不用or查询"><a href="#10、尽量不用or查询" class="headerlink" title="10、尽量不用or查询"></a>10、尽量不用or查询</h2><p>如果使用or，可能导致索引失效。所以要减少or的使用，可以<strong>使用 union all 或者 union 来替代：</strong></p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--使用or进行查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">OR</span> <span class="hljs-type">NAME</span> = <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204307.png"><img src="/mysql2.assets/20200817204307.png" alt="img"></a></p><h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>全职匹配我最爱，最左前缀要遵守</p><p>带头大哥不能死，中间兄弟不能断</p><p>索引列上少计算，范围之后全失效</p><p>LIKE 百分写最右，覆盖索引不写*</p><p>不等空值还有 OR，索引影响要注意</p><p>VARCHAR 引号不可丢，SQL 优化有诀窍</p><h1 id="六、关联查询优化"><a href="#六、关联查询优化" class="headerlink" title="六、关联查询优化"></a>六、关联查询优化</h1><p><strong>建表语句</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs scss">CREATE <span class="hljs-selector-tag">TABLE</span> IF NOT EXISTS `class` (<br>`id` INT(<span class="hljs-number">10</span>) UNSIGNED NOT NULL AUTO_INCREMENT, `card` <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) UNSIGNED NOT NULL, PRIMARY KEY (`id`)<br>);<br>CREATE <span class="hljs-selector-tag">TABLE</span> IF NOT EXISTS `book` (<br>`bookid` INT(<span class="hljs-number">10</span>) UNSIGNED NOT NULL AUTO_INCREMENT, `card` <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) UNSIGNED NOT NULL, PRIMARY KEY (`bookid`)<br>);<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">class</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));<br>INSERT INTO <span class="hljs-built_in">book</span>(card) <span class="hljs-built_in">VALUES</span>(FLOOR(<span class="hljs-number">1</span> + (RAND() * <span class="hljs-number">20</span>)));Copy<br></code></pre></td></tr></table></figure><h2 id="1、LEFT-JOIN优化"><a href="#1、LEFT-JOIN优化" class="headerlink" title="1、LEFT JOIN优化"></a>1、LEFT JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--未建立索引时的左外连接查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">LEFT JOIN</span> book <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>.card = book.card;<br><br><span class="hljs-comment">--左表（class）建立索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_class_card <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>(card);<br><br><span class="hljs-comment">--再次执行查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">LEFT JOIN</span> book <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>.card = book.card;<br><br><span class="hljs-comment">--去掉左表索引</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_class_card <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>;<br><br><span class="hljs-comment">--右表建立索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_book_card <span class="hljs-keyword">ON</span> book(card);<br><br><span class="hljs-comment">--再次执行查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">LEFT JOIN</span> book <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>.card = book.card;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170458.png"><img src="/mysql2.assets/20200818170458.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170402.png"><img src="/mysql2.assets/20200818170402.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170547.png"><img src="/mysql2.assets/20200818170547.png" alt="img"></a></p><p><strong>结论</strong></p><ul><li>在优化关联查询时，只有在<strong>被驱动表上建立索引才有效</strong></li><li>left join 时，左侧的为驱动表，<strong>右侧为被驱动表</strong></li></ul><h2 id="2、INNER-JOIN优化"><a href="#2、INNER-JOIN优化" class="headerlink" title="2、INNER JOIN优化"></a>2、INNER JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--查询操作，目前索引在book表的card上，class表和book表的位置不会改变查询结果</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>.card = book.card;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">ON</span> book.card = <span class="hljs-keyword">class</span>.card;<br><br><span class="hljs-comment">--删除book表中的几条记录</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> bookid&lt;<span class="hljs-number">10</span>;<br><br><span class="hljs-comment">--再次查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>.card = book.card;<br><br><span class="hljs-comment">--删除book表card字段索引，给class表的card字段添加索引</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_book_card <span class="hljs-keyword">ON</span> book;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_class_card <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>(card);<br><br><span class="hljs-comment">--再次查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>.card = book.card;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171341.png"><img src="/mysql2.assets/20200818171341.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171538.png"><img src="/mysql2.assets/20200818171538.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171625.png"><img src="/mysql2.assets/20200818171625.png" alt="img"></a></p><p><strong>结论</strong>：inner join 时，<strong>mysql 会把小结果集的表选为驱动表</strong>（小表驱动大表）</p><p><strong>所以最好把索引建立在大表（数据较多的表）上</strong></p><h2 id="3、RIGHT-JOIN优化"><a href="#3、RIGHT-JOIN优化" class="headerlink" title="3、RIGHT JOIN优化"></a>3、RIGHT JOIN优化</h2><p>优化类型和LEFT JOIN类似，只不过<strong>被驱动表变成了左表</strong></p><h1 id="七、排序分组优化"><a href="#七、排序分组优化" class="headerlink" title="七、排序分组优化"></a>七、排序分组优化</h1><p>在查询中难免会对查询结果进行排序操作。进行排序操作时要<strong>避免出现 Using filesort</strong>，应使用索引给排序带来的方便</p><p><strong>索引信息</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819160428.png"><img src="/mysql2.assets/20200819160428.png" alt="img"></a></p><h2 id="1、ORDER-BY-优化"><a href="#1、ORDER-BY-优化" class="headerlink" title="1、ORDER BY 优化"></a>1、ORDER BY 优化</h2><p>以下查询都是在<strong>索引覆盖</strong>的条件下进行的</p><p><strong>SQL语句</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--不满足索引覆盖时进行排序查询</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;<br><br><span class="hljs-comment">--按照复合索引顺序进行排序</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId, <span class="hljs-type">name</span>;<br><br><span class="hljs-comment">--不按照复合索引顺序进行排序（无 age 字段），发生Using filesort</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-type">name</span>;<br><br><span class="hljs-comment">--不按照复合索引顺序进行排序（索引顺序打乱），发生Using filesort</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-type">name</span>, age;<br><br><span class="hljs-comment">--排序时部分(age)升序，部分(deptId)降序，发生Using filesort</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>, deptId <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">--排序时都为降序</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>, deptId <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">--排序时，在前面的字段为常量时（非范围）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-type">name</span>;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId&gt;<span class="hljs-number">10000</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-type">name</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162506.png"><img src="/mysql2.assets/20200819162506.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="/mysql2.assets/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="/mysql2.assets/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="/mysql2.assets/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162314.png"><img src="/mysql2.assets/20200819162314.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200907210532.png"><img src="/mysql2.assets/20200907210532.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162429.png"><img src="/mysql2.assets/20200819162429.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162901.png"><img src="/mysql2.assets/20200819162901.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164020.png"><img src="/mysql2.assets/20200819164020.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164317.png"><img src="/mysql2.assets/20200819164317.png" alt="img"></a></p><p><strong>结论</strong>：</p><p>要想在排序时使用索引，避免 Using filesort，首先需要发生<strong>索引覆盖</strong>，其次</p><ul><li>ORDER BY 后面字段的顺序要和复合索引的<strong>顺序完全一致</strong></li><li>ORDER BY 后面的索引必须按照顺序出现，<strong>排在后面的可以不出现</strong></li><li>要进行升序或者降序时，<strong>字段的排序顺序必须一致</strong>。不能一部分升序，一部分降序，可以都升序或者都降序</li><li>如果复合索引前面的<strong>字段作为常量</strong>出现在过滤条件中，<strong>排序字段可以为紧跟其后的字段</strong></li></ul><h3 id="MySQL的排序算法"><a href="#MySQL的排序算法" class="headerlink" title="MySQL的排序算法"></a>MySQL的排序算法</h3><p>当发生 Using filesort 时，MySQL会根据自己的算法对查询结果进行排序</p><ul><li>双路排序<ul><li>MySQL 4.1 之前是使用双路排序,字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段</li><li>简单来说，<strong>取一批数据，要对磁盘进行了两次扫描</strong>，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序</li></ul></li><li>单路排序<ul><li>从磁盘读取查询需要的所有列，按照 order by 列<strong>在 buffer 对它们进行排序</strong>，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li><li><strong>存在的问题</strong>：在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能<strong>取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多 路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I&#x2F;O。也就是<strong>本来想省一次 I&#x2F;O 操作，反而导致了大量的 I&#x2F;O 操作，反而得不偿失</strong></li></ul></li><li>优化Using filesort<ul><li>增大 sort_butter_size 参数的设置<ul><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对<strong>每个进程的 1M-8M 之间调整</strong></li></ul></li><li>增大 max_length_for_sort_data 参数的设置<ul><li>mysql 使用单路排序的前提是<strong>排序的字段大小要小于 max_length_for_sort_data</strong></li><li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大， 明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。（1024-8192 之间调整）</li></ul></li><li>减少 select 后面的查询的字段<ul><li>查询的字段减少了，缓冲里就能容纳更多的内容了，<strong>间接增大了sort_buffer_size</strong></li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164341.png"><img src="/mysql2.assets/20200819164341.png" alt="img"></a></p><h2 id="2、GROUP-BY-优化"><a href="#2、GROUP-BY-优化" class="headerlink" title="2、GROUP BY 优化"></a>2、GROUP BY 优化</h2><p>优化方式和 ORDER BY 类似，参考ORDER BY 的优化方式即可</p><h1 id="八、截取查询分析"><a href="#八、截取查询分析" class="headerlink" title="八、截取查询分析"></a>八、截取查询分析</h1><h2 id="1、慢日志查询"><a href="#1、慢日志查询" class="headerlink" title="1、慢日志查询"></a>1、慢日志查询</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，<strong>它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中</li><li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句</li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们<strong>手动</strong>来设置这个参数</p><p>如果不是调优需要的话，<strong>一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件</p><table><thead><tr><th>SQL 语句</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘%slow_query_log%’</td><td>查看慢查询日志是否开启</td><td>默认情况下 slow_query_log 的值为 OFF</td></tr><tr><td>set global slow_query_log&#x3D;1</td><td>开启慢查询日志</td><td></td></tr><tr><td>SHOW VARIABLES LIKE ‘long_query_time%’</td><td>查看慢查询设定阈值</td><td>单位：秒</td></tr><tr><td>set long_query_time&#x3D;1</td><td>设定慢查询阈值</td><td>单位：秒</td></tr></tbody></table><p>运行查询时间长的 sql，<strong>可以打开慢查询日志查看</strong></p><h2 id="2、批量数据脚本"><a href="#2、批量数据脚本" class="headerlink" title="2、批量数据脚本"></a>2、批量数据脚本</h2><h3 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--dept 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `dept` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, ceo <span class="hljs-type">INT</span> <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-comment">-- emp 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `emp` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `empno` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `age` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `deptId` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>#<span class="hljs-keyword">CONSTRAINT</span> `fk_dept_id` <span class="hljs-keyword">FOREIGN</span> KEY (`deptId`) <span class="hljs-keyword">REFERENCES</span> `t_dept` (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p>在执行创建函数之前，首先请保证 log_bin_trust_function_creators 参数为 1，即 on 开启状态。 否则会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询</span><br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_bin_trust_function_creators&#x27;</span>;<br><br><span class="hljs-comment">--设置</span><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> log_bin_trust_function_creators<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="编写随机函数"><a href="#编写随机函数" class="headerlink" title="编写随机函数"></a>编写随机函数</h3><h4 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a><strong>随机产生字符串</strong></h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--DELIMITER 是用于改变结束的标志的，一般以分号结尾，但这里改为了以 $$ 结尾</span><br><span class="hljs-keyword">DELIMITER</span> $$<span class="language-pgsql"></span><br><span class="language-pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_string(n <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>)</span><br><span class="language-pgsql"><span class="hljs-keyword">BEGIN</span></span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> chars_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> return_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">WHILE</span> i &lt; n <span class="hljs-keyword">DO</span></span><br><span class="language-pgsql"><span class="hljs-keyword">SET</span> return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(<span class="hljs-number">1</span>+RAND()*<span class="hljs-number">52</span>),<span class="hljs-number">1</span>));</span><br><span class="language-pgsql"><span class="hljs-keyword">SET</span> i = i + <span class="hljs-number">1</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">RETURN</span> return_str;</span><br><span class="language-pgsql"><span class="hljs-keyword">END</span> $$</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>如果要<strong>删除函数</strong>，则执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> rand_string;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="随机产生部门编号"><a href="#随机产生部门编号" class="headerlink" title="随机产生部门编号"></a>随机产生部门编号</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DELIMITER</span> $$<span class="language-pgsql"></span><br><span class="language-pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_num (from_num <span class="hljs-type">INT</span> ,to_num <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)</span><br><span class="language-pgsql"><span class="hljs-keyword">BEGIN</span></span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">SET</span> i = FLOOR(from_num +RAND()*(to_num -from_num+<span class="hljs-number">1</span>)) ;</span><br><span class="language-pgsql"><span class="hljs-keyword">RETURN</span> i;</span><br><span class="language-pgsql"><span class="hljs-keyword">END</span>$$</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>如果要<strong>删除函数</strong>，则执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> rand_num;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><h4 id="创建往-emp-表中插入数据的存储过程"><a href="#创建往-emp-表中插入数据的存储过程" class="headerlink" title="创建往 emp 表中插入数据的存储过程"></a>创建往 emp 表中插入数据的存储过程</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title function_">insert_emp</span><span class="hljs-params">( START INT , max_num INT )</span><br><span class="hljs-title function_">BEGIN</span><br><span class="hljs-title function_">DECLARE</span> <span class="hljs-title function_">i</span> <span class="hljs-title function_">INT</span> <span class="hljs-title function_">DEFAULT</span> 0;<br>#<span class="hljs-keyword">set</span> autocommit =<span class="hljs-number">0</span> 把 autocommit 设置成 <span class="hljs-number">0</span><br><span class="hljs-keyword">SET</span> autocommit = <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br><span class="hljs-keyword">REPEAT</span><br><span class="hljs-keyword">SET</span> i = i + <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br>INSERT <span class="hljs-keyword">INTO</span> emp (empno, NAME ,age ,deptid ) VALUES ((START+i) ,rand_string(<span class="hljs-number">6</span>) , rand_num(<span class="hljs-number">30</span>,<span class="hljs-number">50</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>))<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">UNTIL</span> i = max_num<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">REPEAT</span><span class="hljs-punctuation">;</span><br>COMMIT<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">END</span>$$<br><br>--删除<br>-- DELIMITER <span class="hljs-punctuation">;</span><br>-- drop <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title function_">insert_emp</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="创建往-dept-表中插入数据的存储过程"><a href="#创建往-dept-表中插入数据的存储过程" class="headerlink" title="创建往 dept 表中插入数据的存储过程"></a>创建往 dept 表中插入数据的存储过程</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">--执行存储过程，往 dept 表添加随机数据<br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `<span class="hljs-title function_">insert_dept</span>`<span class="hljs-params">( max_num INT )</span><br><span class="hljs-title function_">BEGIN</span><br><span class="hljs-title function_">DECLARE</span> <span class="hljs-title function_">i</span> <span class="hljs-title function_">INT</span> <span class="hljs-title function_">DEFAULT</span> 0;<br><span class="hljs-keyword">SET</span> autocommit = <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br><span class="hljs-keyword">REPEAT</span><br><span class="hljs-keyword">SET</span> i = i + <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br>INSERT <span class="hljs-keyword">INTO</span> dept ( deptname,address,ceo ) VALUES (rand_string(<span class="hljs-number">8</span>),rand_string(<span class="hljs-number">10</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>))<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">UNTIL</span> i = max_num<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">REPEAT</span><span class="hljs-punctuation">;</span><br>COMMIT<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">END</span>$$<br><br>--删除<br>-- DELIMITER <span class="hljs-punctuation">;</span><br>-- drop <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title function_">insert_dept</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><h4 id="添加数据到部门表"><a href="#添加数据到部门表" class="headerlink" title="添加数据到部门表"></a>添加数据到部门表</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--执行存储过程，往 dept 表添加 1 万条数据</span><br><span class="hljs-keyword">DELIMITER</span> ;<br><span class="hljs-keyword">CALL</span> insert_dept(<span class="hljs-number">10000</span>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="添加数据到员工表"><a href="#添加数据到员工表" class="headerlink" title="添加数据到员工表"></a>添加数据到员工表</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--执行存储过程，往 emp 表添加 50 万条数据</span><br><span class="hljs-keyword">DELIMITER</span> ;<br><span class="hljs-keyword">CALL</span> insert_emp(<span class="hljs-number">100000</span>,<span class="hljs-number">500000</span>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="批量删除某个表上的所有索引"><a href="#批量删除某个表上的所有索引" class="headerlink" title="批量删除某个表上的所有索引"></a>批量删除某个表上的所有索引</h3><h4 id="删除索引的存储过程"><a href="#删除索引的存储过程" class="headerlink" title="删除索引的存储过程"></a>删除索引的存储过程</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DELIMITER</span> $$<span class="language-pgsql"></span><br><span class="language-pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),tablename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>))</span><br><span class="language-pgsql"><span class="hljs-keyword">BEGIN</span></span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> done <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> ct <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> _index <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> _cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> index_name <span class="hljs-keyword">FROM</span> information_schema.<span class="hljs-keyword">STATISTICS</span> <span class="hljs-keyword">WHERE</span></span><br><span class="language-pgsql">table_schema=dbname <span class="hljs-keyword">AND</span> <span class="hljs-built_in">table_name</span>=tablename <span class="hljs-keyword">AND</span> seq_in_index=<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> index_name &lt;&gt;<span class="hljs-string">&#x27;PRIMARY&#x27;</span> ;</span><br><span class="language-pgsql"><span class="hljs-keyword">DECLARE</span> <span class="hljs-keyword">CONTINUE</span> <span class="hljs-keyword">HANDLER</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-built_in">FOUND</span> <span class="hljs-keyword">set</span> done=<span class="hljs-number">2</span> ;</span><br><span class="language-pgsql"><span class="hljs-keyword">OPEN</span> _cur;</span><br><span class="language-pgsql"><span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index;</span><br><span class="language-pgsql"><span class="hljs-keyword">WHILE</span> _index&lt;&gt;<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">DO</span></span><br><span class="language-pgsql"><span class="hljs-keyword">SET</span> @str = CONCAT(&quot;drop index &quot;,_index,&quot; on &quot;,tablename );</span><br><span class="language-pgsql"><span class="hljs-keyword">PREPARE</span> sql_str <span class="hljs-keyword">FROM</span> @str ;</span><br><span class="language-pgsql"><span class="hljs-keyword">EXECUTE</span> sql_str;</span><br><span class="language-pgsql"><span class="hljs-keyword">DEALLOCATE</span> <span class="hljs-keyword">PREPARE</span> sql_str;</span><br><span class="language-pgsql"><span class="hljs-keyword">SET</span> _index=<span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index;</span><br><span class="language-pgsql"><span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span>;</span><br><span class="language-pgsql"><span class="hljs-keyword">CLOSE</span> _cur;</span><br><span class="language-pgsql"><span class="hljs-keyword">END</span>$$</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">CALL</span> proc_drop_index(<span class="hljs-string">&quot;dbname&quot;</span>,<span class="hljs-string">&quot;tablename&quot;</span>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h1 id="九、MySQL锁机制"><a href="#九、MySQL锁机制" class="headerlink" title="九、MySQL锁机制"></a>九、MySQL锁机制</h1><h2 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h2><p><strong>MylSAM引擎使用表锁，并且不支持事务</strong></p><p><strong>SQL语句</strong></p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cos">--展示表是否加锁<br>SHOW <span class="hljs-keyword">OPEN</span> TABLES<span class="hljs-comment">;</span><br><br>--加锁 <span class="hljs-keyword">read</span> (读锁) <span class="hljs-keyword">write</span> (写锁)<br><span class="hljs-keyword">LOCK</span> TABLE table1 <span class="hljs-keyword">read</span>(<span class="hljs-keyword">write</span>), table2 <span class="hljs-keyword">read</span>(<span class="hljs-keyword">write</span>)...<br><br>--全部解锁<br>UNLOCK TABLES<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><ul><li>主机A给表加上<strong>表锁（读锁）</strong>以后<ul><li>主机A和其他主机都可以读取<strong>该表</strong>的信息</li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中所有表的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，<strong>会修改失败</strong></li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加锁并查询状态</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span> dept <span class="hljs-keyword">READ</span>;<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> <span class="hljs-keyword">TABLES</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151441.png"><img src="/mysql2.assets/20200820151441.png" alt="img"></a></p></li></ul><p><strong>读取</strong></p><ul><li><p>两个客户端分别读取dept表的信息，都能读出来</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li><li><p>客户端A（加锁端）A<strong>读取其他表</strong>信息，<strong>读取失败</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp<span class="hljs-punctuation">;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152614.png"><img src="/mysql2.assets/20200820152614.png" alt="img"></a></p></li><li><p>其他客户端读取度其他表信息，读取成功</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp<span class="hljs-punctuation">;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152714.png"><img src="/mysql2.assets/20200820152714.png" alt="img"></a></p></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A对表中内容进行修改，<strong>修改失败</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151654.png"><img src="/mysql2.assets/20200820151654.png" alt="img"></a></p></li><li><p>客户端B对表中内容进行修改，进入阻塞状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151737.png"><img src="/mysql2.assets/20200820151737.png" alt="img"></a></p><ul><li><p>从客户端A解锁后，客户端B修改成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">UNLOCK <span class="hljs-keyword">TABLES</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151818.png"><img src="/mysql2.assets/20200820151818.png" alt="img"></a></p></li></ul><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>主机A给表加上<strong>表锁（写锁）</strong>以后</p><ul><li>主机A可以读取该表信息，但<strong>其他主机读取时，会进入阻塞状态，知道读锁被释放</strong></li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中<strong>除该表以外所有表</strong>的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，修改成功</li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加上写锁并查看</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span> dept <span class="hljs-keyword">WRITE</span>;<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> <span class="hljs-keyword">TABLES</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153259.png"><img src="/mysql2.assets/20200820153259.png" alt="img"></a></p></li></ul><p><strong>读取</strong></p><ul><li><p>客户端A查询该表内容，查询成功；读取其他表，读取失败</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept<span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp<span class="hljs-punctuation">;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153403.png"><img src="/mysql2.assets/20200820153403.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153437.png"><img src="/mysql2.assets/20200820153437.png" alt="img"></a></p><ul><li><p>其他表读取该表信息，进入阻塞状态</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept<span class="hljs-punctuation">;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153517.png"><img src="/mysql2.assets/20200820153517.png" alt="img"></a></p></li><li><p>释放后，读取成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">UNLOCK <span class="hljs-keyword">TABLES</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A修改<strong>该表</strong>内容，修改成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153637.png"><img src="/mysql2.assets/20200820153637.png" alt="img"></a></p></li><li><p>客户端A修改<strong>其他表</strong>内容，修改失败</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153710.png"><img src="/mysql2.assets/20200820153710.png" alt="img"></a></p></li><li><p>其他客户端修改<strong>该表</strong>内容，进入阻塞状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>读锁不会阻塞读，只会阻塞写。但是写锁会阻塞读和写。</strong></p><h2 id="2、行锁"><a href="#2、行锁" class="headerlink" title="2、行锁"></a>2、行锁</h2><p><strong>InnoDB使用行锁，并且支持事务</strong>，事务相关可参考 <a href="https://nyimac.gitee.io/2020/08/11/MySQL%E5%9F%BA%E7%A1%80/#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1"><strong>MySQL基础</strong></a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>如果两个客户端<strong>对同一条记录进行修改</strong></p><ul><li>客户端A修改后，未提交（未commit），此时客户端B修改，则会阻塞</li><li>客户端A修改后，提交后，客户端B再修改，则不会阻塞</li></ul><p>如果两个客户端分别<strong>对不同的记录进行修改</strong>，则不会被阻塞</p><p><strong>修改同一条记录</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--关闭自动提交</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">--客户端A、B查询id=2的记录</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端A进行修改操作（将年龄改为了80），但未提交</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">80</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端A进行查询</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端B进行查询</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端B进行修改（客户端A未提交）</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端A提交</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">--客户端B提交</span><br><span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p>客户端A查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="/mysql2.assets/20200820163718.png" alt="img"></a></p><p>客户端B查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="/mysql2.assets/20200820163718.png" alt="img"></a></p><p>客户端A修改后A查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163847.png"><img src="/mysql2.assets/20200820163847.png" alt="img"></a></p><p>客户端A修改后B查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="/mysql2.assets/20200820163718.png" alt="img"></a></p><p>客户端A修改，未提交，此时B进行修改，<strong>被阻塞</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163957.png"><img src="/mysql2.assets/20200820163957.png" alt="img"></a></p><p>客户端A提交后，B修改成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820164036.png"><img src="/mysql2.assets/20200820164036.png" alt="img"></a></p><p><strong>修改不同记录</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--客户端A对id=2的年龄进行修改</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端B对id=3的年龄进行修改</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">--客户端A，B分别提交</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>因为InnoDB使用行锁，对于不同行的操作，不会出现阻塞现象</p><h3 id="索引失效-1"><a href="#索引失效-1" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，<strong>行锁变表锁</strong></p><p>当<strong>索引失效</strong>后，即使多个客户端操作的不是同一条记录，<strong>如果未提交，其他客户端也会进入阻塞状态</strong></p><p>所以要<strong>避免索引失效</strong></p><h3 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</p><p>对于键值<strong>在条件范围内但并不存在的记录</strong>，叫做<strong>“间隙(GAP)<strong>” ，</strong>InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询表记录，此处没有id=2的记录</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;<br><br><span class="hljs-comment">--客户端A进行范围查询，但是范围内没有id=2的记录</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">--客户端B进行插入数据，插入一条id=2的记录</span><br><span class="hljs-keyword">INSERT</span> t_emp <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;岳不群&#x27;</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100002</span>); <br><br><span class="hljs-comment">--客户端A提交</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">--客户端B提交</span><br><span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170126.png"><img src="/mysql2.assets/20200820170126.png" alt="img"></a></p><p><strong>客户端B进入阻塞状态</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170617.png"><img src="/mysql2.assets/20200820170617.png" alt="img"></a></p><p>提交后，插入成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170654.png"><img src="/mysql2.assets/20200820170654.png" alt="img"></a></p><p><strong>结论</strong>：可以看到表中本来<strong>没有id&#x3D;2的记录</strong>，但是在客户端A进行<strong>范围修改</strong>时，客户端B对<strong>在范围内但不存在的数据进行插入时，客户端B进入了阻塞状态</strong></p><h3 id="锁住指定的一行"><a href="#锁住指定的一行" class="headerlink" title="锁住指定的一行"></a>锁住指定的一行</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-comment">--锁住指定的一行，如果进行更新操作就是 ... FOR UPDATE，删除操作就是 ... FOR DELETE 以此类推</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br><br><span class="hljs-comment">--进行修改操作</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> <span class="hljs-type">NAME</span> = <span class="hljs-string">&#x27;风车车&#x27;</span> <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">--提交</span><br><span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>如果当某一行被锁住后，其他客户端对改行进行操作，会被<strong>阻塞</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Innodb存储引擎由于实现了<strong>行级锁定</strong>，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些， 但是在整体<strong>并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们<strong>使用不当的时候</strong>，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。</p><h1 id="十、复制"><a href="#十、复制" class="headerlink" title="十、复制"></a>十、复制</h1><h2 id="1、主从复制"><a href="#1、主从复制" class="headerlink" title="1、主从复制"></a>1、主从复制</h2><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改<strong>写入二进制日志</strong>（Binary log）中。</li><li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并<strong>写入从服务器的中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133613.png"><img src="/mysql2.assets/20200822133613.png" alt="img"></a></p><h2 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h2><p><strong>主服务器处理写操作</strong>以及实时性要求比较高的读操作，而<strong>从服务器处理读操作</strong></p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度<strong>缓解了锁的争用</strong></li><li><strong>从服务器</strong>可以使用 <a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E5%BC%95%E6%93%8E%E5%B1%82">MyISAM</a>，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133739.png"><img src="/mysql2.assets/20200822133739.png" alt="img"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/2022/03/11/javac_oncurrency/"/>
    <url>/2022/03/11/javac_oncurrency/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql基础</title>
    <link href="/2022/03/11/mysql1/"/>
    <url>/2022/03/11/mysql1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mysql安装以及配置"><a href="#一、Mysql安装以及配置" class="headerlink" title="一、Mysql安装以及配置"></a>一、Mysql安装以及配置</h1><p>LInux：移步<a href="https://zhuanlan.zhihu.com/p/472517343">Linux (centos)安装Mysql8.0+ - 知乎 (zhihu.com)</a></p><p>Window：进入Oracle官网下载msi或者zip压缩包即可</p><h1 id="二、Mysql基本操作语句"><a href="#二、Mysql基本操作语句" class="headerlink" title="二、Mysql基本操作语句"></a>二、Mysql基本操作语句</h1><p>移步：<a href="https://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.html</a></p><h1 id="三、Mysql函数和存储过程"><a href="#三、Mysql函数和存储过程" class="headerlink" title="三、Mysql函数和存储过程"></a>三、Mysql函数和存储过程</h1><p>MySQL的存储过程（stored procedure）和函数（stored function）统称为stored routines。它是事先经过编译并存储在数据库中的一段SQL语句的集合。</p><p><strong>存储过程（Stored Procedure）</strong>是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><strong>函数（Stored Function）</strong>：是由一个或多个SQL语句组成的子程序，可用于封装代码以便重新使用。自定义函数诸多限制，有许多语句不能使用，许多功能不能实现。函数可以直接引用返回值，用表变量返回记录集。但是，用户定义函数不能用于执行一组修改全局数据库状态的操作。</p><h2 id="1、存储过程与函数的区别"><a href="#1、存储过程与函数的区别" class="headerlink" title="1、存储过程与函数的区别"></a>1、<strong>存储过程与函数的区别</strong></h2><p>本质上没区别。函数只能通过return语句返回单个值或者表对象。而存储过程不允许执行return，但是通过out参数返回多个值。 函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程不行。函数限制比较多，如不能用临时表，只能用表变量等，而存储过程的限制相对就比较少。</p><ol><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强</li><li>当对数据库进行复杂操作时(如对多个表进行Update、Insert、Query、Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。<a href="http://blog.csdn.net/xiaohutushen/article/details/1956429">存储过程可以从自己的存储过程内引用其它存储过程</a>，这可以简化一系列复杂语句</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面</li><li>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度</li><li>存储过程可以接受参数、输出参数、返回单个或多个结果集以及返回值，可以向程序返回错误原因。但函数只能返回一个特定类型的值或者表对象</li><li>存储过程中的CRUD的操作会影响数据库状态，但函数却不能</li><li>函数只能是in类型，存储过程可以使用In\out\inout类型</li></ol><h2 id="2、函数定义与使用"><a href="#2、函数定义与使用" class="headerlink" title="2、函数定义与使用"></a>2、函数定义与使用</h2><h2 id="3、存储过程定于与使用"><a href="#3、存储过程定于与使用" class="headerlink" title="3、存储过程定于与使用"></a>3、存储过程定于与使用</h2><h1 id="四、约束"><a href="#四、约束" class="headerlink" title="四、约束"></a>四、约束</h1><h2 id="1、主键"><a href="#1、主键" class="headerlink" title="1、主键"></a>1、主键</h2><p>能够唯一确定表中的一条记录。我们通过给某个字段添加该约束，就可以使得该字段不重复且不为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="2、联合主键"><a href="#2、联合主键" class="headerlink" title="2、联合主键"></a>2、联合主键</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user2 (<br>id <span class="hljs-type">INT</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(id, name)<br>);<br></code></pre></td></tr></table></figure><p>此处字段id和name一同作为主键，联合主键要求每个字段<strong>加起来不同即可</strong>（无需每个字段都不同）</p><p><strong>建表后添加主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id);<br></code></pre></td></tr></table></figure><p>或者通过<strong>修改字段</strong>的方式来添加主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 MODIFY id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure><p><strong>建表后删除主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 <span class="hljs-keyword">DROP</span>  <span class="hljs-keyword">PRIMARY</span> KEY (id);<br></code></pre></td></tr></table></figure><h2 id="2、自增约束"><a href="#2、自增约束" class="headerlink" title="2、自增约束"></a>2、自增约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user3 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user3 (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>插入成功，自动生成了id<br></code></pre></td></tr></table></figure><p>自增约束一般<strong>与主键搭配使用</strong></p><h2 id="3、唯一约束"><a href="#3、唯一约束" class="headerlink" title="3、唯一约束"></a>3、唯一约束</h2><p>约束修饰的字段不可以重复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT <span class="hljs-keyword">UNIQUE</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br><span class="hljs-keyword">UNIQUE</span>(id, name)<br>);<br></code></pre></td></tr></table></figure><h2 id="4、非空约束"><a href="#4、非空约束" class="headerlink" title="4、非空约束"></a>4、非空约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>);<br></code></pre></td></tr></table></figure><h2 id="5、默认约束"><a href="#5、默认约束" class="headerlink" title="5、默认约束"></a>5、默认约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>);<br></code></pre></td></tr></table></figure><p>如果我们插入字段时没有传值，就会<strong>使用默认值</strong></p><h2 id="6、外键约束"><a href="#6、外键约束" class="headerlink" title="6、外键约束"></a>6、外键约束</h2><p>主表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> master(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><p>从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pet(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>master_id <span class="hljs-type">int</span>,<br><span class="hljs-keyword">FOREIGN</span> KEY(master_id) <span class="hljs-keyword">REFERENCES</span> master(id)<br>);<br></code></pre></td></tr></table></figure><ul><li>主表中没有的数据，在副表中是不可以使用的</li><li>主表中的数据被副标引用时，是不可以删除的</li></ul><h1 id="五、数据库范式"><a href="#五、数据库范式" class="headerlink" title="五、数据库范式"></a>五、数据库范式</h1><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><p>通常使用到的有 <strong>1NF</strong>、<strong>2NF</strong>、<strong>3NF</strong>、<strong>BCNF</strong>，在实际开发中最为常见的设计范式用前三个：</p><h2 id="1、第一范式"><a href="#1、第一范式" class="headerlink" title="1、第一范式"></a>1、第一范式</h2><p><strong>字段还可以拆分的，就不满足第一范式</strong></p><p>比如地址如果写为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">地址：陕西省西安市长安区学府大街西北大学</span><br></code></pre></td></tr></table></figure><p>就是可以被拆分的</p><p>如果字段写为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">省份：陕西省</span><br><span class="hljs-string">城市：西安市</span><br><span class="hljs-string">区域：长安区</span><br><span class="hljs-string">街名：学府大街西北大学</span><br></code></pre></td></tr></table></figure><p>就是不可拆分的</p><p>建表如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCRAEMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>province <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>city <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>area <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>street: <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><p>就是<strong>符合第一范式</strong>的，但<strong>并不是拆分的越详细越好</strong></p><h2 id="2、第二范式"><a href="#2、第二范式" class="headerlink" title="2、第二范式"></a>2、第二范式</h2><ul><li>满足第一范式的条件下，第二范式要求：<strong>除主键外的每一列，都必须完全依赖于主键</strong></li><li>如果出现不完全依赖，则只可能发生在<strong>联合主键</strong>的情况下</li></ul><p><strong>不满足第二范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span>,<br>product_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(product_id, customer_id)<br>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>此处product_name只依赖于product_id，customer_name只依赖于customer_id</p><p><strong>满足第二范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="3、第三范式"><a href="#3、第三范式" class="headerlink" title="3、第三范式"></a>3、第三范式</h2><ul><li>满足第二范式，除主键外的其他列之间不能有传递依赖关系</li></ul><p><strong>不满足第三范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span>,<br>customer_phone <span class="hljs-type">INT</span><br>);<br></code></pre></td></tr></table></figure><p>此处customer_phone又依赖于customer_id，存在传递依赖关系，不满足第三范式</p><p><strong>满足第三范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    phone <span class="hljs-type">INT</span><br>);<br></code></pre></td></tr></table></figure><h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><h2 id="1、事务的ACID"><a href="#1、事务的ACID" class="headerlink" title="1、事务的ACID"></a>1、事务的ACID</h2><p><strong>原子性(atomicity)</strong><br>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分操作，这就是事务的原子性。</p><p><strong>一致性 (consistency)</strong><br>数据库总是从一个一致性的状态转换到另外一个一致性的状态。例如在一个事务执行过程中,服务器突然断电，但因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中，而如果事务正常执行且成功提交，那么数据库就转换到了另外一个一致性状态。</p><p><strong>隔离性 (isolation)</strong><br>通常来谠，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p><strong>持久性 (durability)</strong><br>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p><h2 id="2、隔离级别"><a href="#2、隔离级别" class="headerlink" title="2、隔离级别"></a>2、隔离级别</h2><p><strong>READ UNCOMMITTED（未提交读)</strong><br>在 READ UNCOMMITTED 级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这会导致脏读。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED 不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。</p><p><strong>READ COMMITTED（提交读）</strong><br>大多数数据库系统的默认隔离级别都是 READ COMMITTED （但 MySQL 不是）。READCOMMITTED 满足前面提到的隔离性的简单定义：一个事务开始时，只能 “看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别会出现不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</p><p><strong>REPEATABLE READ（可重复读）</strong><br>REPEATABLE READ 解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。所谓幻读，指的是当某个事务 在读取某个范围内的记录时，另外一个事务又在该范围内插人了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB 和XtraDB 存储引擎通过多版本井发控制 (MVCC, Multiversion Concurrency Control)解决了幻读的问题。<strong>可重复读是 MySQL 的默认事务隔离级别</strong>。</p><p><strong>SERIALIZABLE（可串行化）</strong><br>SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE 会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有井发的情况下，才考虑采用该级别。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">脏读：事务<span class="hljs-selector-tag">A</span>在事务<span class="hljs-selector-tag">B</span>修改某个字段数据后，读取该字段值，随后事务发生回滚，此时<span class="hljs-selector-tag">A</span>读到的数据就是&quot;脏的&quot;<br>不可重复度：事务<span class="hljs-selector-tag">A</span>读取某个字段值后，事务<span class="hljs-selector-tag">B</span>修改该字段值，事务<span class="hljs-selector-tag">B</span>提交后，事务<span class="hljs-selector-tag">A</span>再次读取该字段值，两次读取的值不一致<br>幻读：事务<span class="hljs-selector-tag">A</span>读取某字段值后，会给该字段上锁(注意是行锁)，此时事务<span class="hljs-selector-tag">A</span>执行条件查询，查询到一条记录，随后删除，此时<span class="hljs-selector-tag">B</span>可以Insert一条与删除记录一样的记录，此时事务<span class="hljs-selector-tag">A</span>再次执行查询，又发现了一条记录<br></code></pre></td></tr></table></figure><table><thead><tr><th>隔离级别</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th></tr></thead><tbody><tr><td>读未提交</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>读已提交</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>可重复读</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>串行化</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><p><strong>总结</strong>：不可重复读的和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong></p><p>默认情况下，Mysql是自动提交的，也就是我们每次输入一条语句然后回车，这也执行了一个事务。</p><h2 id="3、事务操作"><a href="#3、事务操作" class="headerlink" title="3、事务操作"></a>3、事务操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">查看自动提交状态<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span>; <span class="hljs-comment">--带@@的变量为系统变量</span><br>关闭自动提交<br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><br>此时可以输入执行任意多条语句<br>执行<span class="hljs-keyword">ROLLBACK</span>回滚到上次提提交后状态<br>执行<span class="hljs-keyword">COMMIT</span>则提交此次事务<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">也可以手动开启一个事务<br><span class="hljs-keyword">BEGIN</span>; <span class="hljs-comment">-- 或者 START TRANSACTION;</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;老六&#x27;</span>, <span class="hljs-number">7</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;老七&#x27;</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">ROLLBACK</span>; <span class="hljs-comment">-- 回滚</span><br><span class="hljs-keyword">COMMIT</span>; <span class="hljs-comment">-- 提交</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
